/* This file was generated by https://github.com/dested/serverless-client-builder */
/* tslint:disable */
import {ClientTransformOptions, ClientOptions, ClientSocketOptions, ControllerOptions} from './baseClient';
declare type ObjectId = string;

export class AnalyticsClient {
  static async event<TPromise = VoidResponse>(
    model: EventRequest,
    handle: {200?: (result: VoidResponse) => void; 500?: (result: string) => void; 401?: (error: string) => void}
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/analytics/event?';

    return makeRequest(url, model, 'POST', handle);
  }

  static async $meta<TPromise = MetaResponse>(
    model: VoidRequest,
    handle: {200?: (result: MetaResponse) => void; 500?: (result: string) => void; 401?: (error: string) => void}
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/analytics/meta?';

    return makeRequest(url, model, 'POST', handle);
  }
}

export class GameDetailsClient {
  static async getGames<TPromise = GetGamesResponse>(
    model: VoidRequest,
    handle: {200?: (result: GetGamesResponse) => void; 500?: (result: string) => void; 401?: (error: string) => void}
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/game-details/?';

    return makeGetRequest(url, model, 'GET', handle);
  }

  static async getGameDetails<TPromise = GetGameDetailsResponse>(
    model: GetGameDetailsRequest,
    handle: {
      200?: (result: GetGameDetailsResponse) => void;
      500?: (result: string) => void;
      401?: (error: string) => void;
    }
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/game-details/details?';

    return makeGetRequest(url, model, 'GET', handle);
  }

  static async joinLobby<TPromise = JoinLobbyResponse>(
    model: JoinLobbyRequest,
    handle: {
      200?: (result: JoinLobbyResponse) => void;
      500?: (result: string) => void;
      400: (result: {error: string}) => void;
      401?: (error: string) => void;
    }
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/game-details/join-lobby?';

    return makeRequest(url, model, 'POST', handle);
  }

  static async joinGame<TPromise = JoinLobbyResponse>(
    model: JoinLobbyGameRequest,
    handle: {
      200?: (result: JoinLobbyResponse) => void;
      500?: (result: string) => void;
      400: (result: {error: string}) => void;
      401?: (error: string) => void;
    }
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/game-details/join-lobby-game?';

    return makeRequest(url, model, 'POST', handle);
  }

  static async startPrivateLobby<TPromise = JoinLobbyResponse>(
    model: StartPrivateLobbyRequest,
    handle: {
      200?: (result: JoinLobbyResponse) => void;
      500?: (result: string) => void;
      400: (result: {error: string}) => void;
      401?: (error: string) => void;
    }
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/game-details/start-private-lobby?';

    return makeRequest(url, model, 'POST', handle);
  }
}

export class LobbySocketClient {
  socket?: WebSocket;
  events?: LobbySocketEvents;
  connect(events: LobbySocketEvents) {
    this.events = events;
    this.socket = new WebSocket(ClientSocketOptions.baseUrl);
    this.socket.onmessage = message => {
      if (!this.events) return;
      const response = JSON.parse(message.data);
      switch (response.event) {
        case 'lobbyPlayers':
          this.events.onLobbyPlayers && this.events.onLobbyPlayers(response.data);
          break;

        case 'lobbyDetails':
          this.events.onLobbyDetails && this.events.onLobbyDetails(response.data);
          break;
      }
    };
    this.socket.onclose = e => {
      this.events?.onDisconnect && this.events?.onDisconnect();
    };
    this.socket.onopen = () => {
      this.events?.onConnect && this.events?.onConnect();
    };
  }
  disconnect() {
    this.socket && this.socket.close();
  }

  join(request: PlayerJoinRequest): void {
    this.socket &&
      this.socket.send(
        JSON.stringify({
          action: 'join',
          jwt: ClientSocketOptions.getJwt(),
          data: request,
        })
      );
  }
}

export interface LobbySocketEvents {
  onLobbyPlayers: (req: LobbyPlayersResponse) => void;

  onLobbyDetails: (req: LobbyDetailsResponse) => void;

  onDisconnect: () => void;
  onConnect: () => void;
}

export class PlayerClient {
  static async getPlayerDetails<TPromise = LoginResponse>(
    model: VoidRequest,
    handle: {200?: (result: LoginResponse) => void; 500?: (result: string) => void; 401?: (error: string) => void}
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/player/details?';

    return makeGetRequest(url, model, 'GET', handle);
  }

  static async login<TPromise = LoginResponse>(
    model: LoginRequest,
    handle: {
      200?: (result: LoginResponse) => void;
      500?: (result: string) => void;
      400: (result: {error: string}) => void;
      401?: (error: string) => void;
    }
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/player/login?';

    return makeRequest(url, model, 'POST', handle);
  }

  static async register<TPromise = LoginResponse>(
    model: RegisterRequest,
    handle: {
      200?: (result: LoginResponse) => void;
      500?: (result: string) => void;
      400: (result: {error: string}) => void;
      401?: (error: string) => void;
    }
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/player/register?';

    return makeRequest(url, model, 'POST', handle);
  }

  static async convertAnon<TPromise = LoginResponse>(
    model: RegisterRequest,
    handle: {
      200?: (result: LoginResponse) => void;
      500?: (result: string) => void;
      400: (result: {error: string}) => void;
      401?: (error: string) => void;
    }
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/player/convert-anon?';

    return makeRequest(url, model, 'POST', handle);
  }

  static async playAnon<TPromise = LoginResponse>(
    model: VoidRequest,
    handle: {
      200?: (result: LoginResponse) => void;
      500?: (result: string) => void;
      400: (result: {error: string}) => void;
      401?: (error: string) => void;
    }
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/player/anon?';

    return makeRequest(url, model, 'POST', handle);
  }
}

export interface EventRequest {
  eventName: string;
  metaData: string;
  time: string;
}

export interface VoidResponse {}

export interface VoidRequest {}

export interface MetaResponse {}

export interface GetGamesResponse {
  games: HttpGameDetailLight[];
}

export interface HttpGameDetailLight {
  id: string;
  logo: string;
  name: string;
  description: string;
}

export interface GetGameDetailsRequest {
  gameId: string;
}

export interface GetGameDetailsResponse {
  details: HttpGameDetail;
}

export interface HttpGameDetail {
  id: string;
  logo: string;
  name: string;
  description: string;
  author: string;
  numberOfActivePlayers: number;

  gameRulesSchema: GameRulesSchema;
  gameRulesDefault: GameRules;
}

export type GameRulesSchema = {
  items: {
    key: string;
    option:
      | {type: 'text'; minLength: number; maxLength: number}
      | {type: 'number'; minValue: number; maxValue: number}
      | {type: 'switch'}
      | {type: 'options'; options: {label: string; value: string}[]};
  }[];
};

export type GameRules = {
  items: {key: string; value: string}[];
};

export interface JoinLobbyRequest {
  gameId: string;
  rules: GameRules;
}

export interface JoinLobbyResponse {
  lobbyId: string;
}

export interface JoinLobbyGameRequest {
  gameId: string;
  lobbyCode: string;
}

export interface StartPrivateLobbyRequest {
  gameId: string;
  rules: GameRules;
}

export interface PlayerJoinRequest {
  playerId: string;
}

export interface LobbyPlayersResponse {
  players: {player: HttpPlayerModel; connected: boolean}[];
}

export type HttpPlayerModel = {
  playerId: string;
  name: string;
  email: string;
  anon: boolean;
};

export interface LobbyDetailsResponse {
  lobby: HttpLobbyDetails;
}

export interface HttpLobbyDetails {
  lobbyId: string;
  gameId: string;
  gameRules: GameRules;
}

export interface LoginResponse {
  jwt: string;
  player: HttpPlayerModel;
}

export interface LoginRequest {
  email: string;
  password: string;
}

export interface RegisterRequest {
  email: string;
  password: string;
  name: string;
}

async function handleResponse(responseText: string, status: number, handle: any) {
  try {
    if (handle[status]) {
      const val = responseText === '' ? null : JSON.parse(responseText);
      await handle[status](val);
      return undefined;
    } else {
      switch (status) {
        case 200: {
          return JSON.parse(responseText);
        }
        case 401: {
          ClientOptions.handleUnauthorized(responseText);
          break;
        }
        case 500: {
          const body = JSON.parse(responseText);
          ClientOptions.handleError(body.error || responseText);
          break;
        }
      }
    }
  } catch (ex) {
    if (!handle[500]) {
      ClientOptions.handleError(ex.toString());
    } else {
      await handle[500](ex.toString());
    }
  }
}
async function makeRequest(url: string, model: any, method: string, handle: any) {
  try {
    const options = {
      method,
    } as RequestInit;

    options.body = JSON.stringify(model);

    const response = await fetch(url, ClientTransformOptions(options));
    const status = response.status;
    const responseText = await response.text();
    return handleResponse(responseText, status, handle);
  } catch (ex) {
    return handleResponse(ex.toString(), 500, handle);
  }
}

async function makeGetRequest(url: string, model: any, method: string, handle: any) {
  try {
    const options = {
      method,
    } as RequestInit;
    url += Object.keys(model)
      .filter(key => !!(model as any)[key])
      .map(key => `${key}=${encodeURIComponent((model as any)[key])}`)
      .join('&');

    const response = await fetch(url, ClientTransformOptions(options));
    const status = response.status;
    const responseText = await response.text();
    return handleResponse(responseText, status, handle);
  } catch (ex) {
    return handleResponse(ex.toString(), 500, handle);
  }
}

/* This file was generated by https://github.com/dested/serverless-client-builder */
/* tslint:disable */
import {ClientTransformOptions, ClientOptions, ClientSocketOptions, ControllerOptions} from './baseClient';
declare type ObjectId = string;

export class AnalyticsClient {
  static async event<TPromise = VoidResponse>(
    model: EventRequest,
    handle: {200?: (result: VoidResponse) => void; 500?: (result: string) => void; 401?: (error: string) => void}
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/analytics/event?';

    return makeRequest(url, model, 'POST', handle);
  }

  static async $meta<TPromise = MetaResponse>(
    model: VoidRequest,
    handle: {200?: (result: MetaResponse) => void; 500?: (result: string) => void; 401?: (error: string) => void}
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/analytics/meta?';

    return makeRequest(url, model, 'POST', handle);
  }
}

export class BroadcastClient {
  static async getGameState<TPromise = BroadcasterGameStateResponse>(
    model: VoidRequest,
    handle: {
      200?: (result: BroadcasterGameStateResponse) => void;
      500?: (result: string) => void;
      401?: (error: string) => void;
    }
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/broadcast/game-state?';

    return makeGetRequest(url, model, 'GET', handle);
  }

  static async auth<TPromise = BroadcasterAuthResponse>(
    model: BroadcasterAuthRequest,
    handle: {
      200?: (result: BroadcasterAuthResponse) => void;
      500?: (result: string) => void;
      404: (result: {error: string}) => void;
      401?: (error: string) => void;
    }
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/broadcast/auth?';

    return makeRequest(url, model, 'POST', handle);
  }
}

export class BroadcastSocketClient {
  socket?: WebSocket;
  events?: BroadcastSocketEvents;
  connect(events: BroadcastSocketEvents) {
    this.events = events;
    this.socket = new WebSocket(ClientSocketOptions.baseUrl);
    this.socket.onmessage = (message) => {
      if (!this.events) return;
      const response = JSON.parse(message.data);
      switch (response.event) {
        case 'newGamePrep':
          this.events.onNewGamePrep && this.events.onNewGamePrep(response.data);
          break;

        case 'newGamePregame':
          this.events.onNewGamePregame && this.events.onNewGamePregame(response.data);
          break;

        case 'newGameStart':
          this.events.onNewGameStart && this.events.onNewGameStart(response.data);
          break;

        case 'playerDead':
          this.events.onPlayerDead && this.events.onPlayerDead(response.data);
          break;

        case 'winner':
          this.events.onWinner && this.events.onWinner(response.data);
          break;

        case 'playerJoin':
          this.events.onPlayerJoin && this.events.onPlayerJoin(response.data);
          break;

        case 'followPlayerUpdate':
          this.events.onFollowPlayerUpdate && this.events.onFollowPlayerUpdate(response.data);
          break;

        case 'jump':
          this.events.onJump && this.events.onJump(response.data);
          break;
      }
    };
    this.socket.onclose = (e) => {
      this.events?.onDisconnect && this.events?.onDisconnect();
    };
    this.socket.onopen = () => {
      this.events?.onConnect && this.events?.onConnect();
    };
  }
  disconnect() {
    this.socket && this.socket.close();
  }
}

export interface BroadcastSocketEvents {
  onNewGamePrep: (req: NewGamePrepResponse) => void;

  onNewGamePregame: (req: NewGamePregameResponse) => void;

  onNewGameStart: (req: NewGameStartResponse) => void;

  onPlayerDead: (req: PlayerDeadResponse) => void;

  onWinner: (req: BroadcasterPlayerWinnerResponse) => void;

  onPlayerJoin: (req: PlayerBroadcastJoinResponse) => void;

  onFollowPlayerUpdate: (req: FollowPlayerResponse) => void;

  onJump: (req: PlayerJumpResponse) => void;

  onDisconnect: () => void;
  onConnect: () => void;
}

export class GameAdminClient {
  static async kickOff<TPromise = KickOffResponse>(
    model: VoidRequest,
    handle: {200?: (result: KickOffResponse) => void; 500?: (result: string) => void; 401?: (error: string) => void}
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/game-admin/kick-off?';

    return makeRequest(url, model, 'POST', handle);
  }
}

export class GameClient {
  static async getCurrentGame<TPromise = GetCurrentGameResponse>(
    model: VoidRequest,
    handle: {
      200?: (result: GetCurrentGameResponse) => void;
      500?: (result: string) => void;
      401?: (error: string) => void;
    }
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/game/game-state?';

    return makeGetRequest(url, model, 'GET', handle);
  }

  static async queueForGame<TPromise = QueueForGameResponse>(
    model: QueueForGameRequest,
    handle: {
      200?: (result: QueueForGameResponse) => void;
      500?: (result: string) => void;
      400: (result: {error: string}) => void;
      402: (result: {error: string}) => void;
      401?: (error: string) => void;
    }
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/game/queue-for-game?';

    return makeRequest(url, model, 'POST', handle);
  }
}

export class GameSocketClient {
  socket?: WebSocket;
  events?: GameSocketEvents;
  connect(events: GameSocketEvents) {
    this.events = events;
    this.socket = new WebSocket(ClientSocketOptions.baseUrl);
    this.socket.onmessage = (message) => {
      if (!this.events) return;
      const response = JSON.parse(message.data);
      switch (response.event) {
        case 'dead':
          this.events.onDead && this.events.onDead(response.data);
          break;

        case 'winner':
          this.events.onWinner && this.events.onWinner(response.data);
          break;

        case 'join':
          this.events.onJoin && this.events.onJoin(response.data);
          break;

        case 'gameStarted':
          this.events.onGameStarted && this.events.onGameStarted(response.data);
          break;

        case 'jump':
          this.events.onJump && this.events.onJump(response.data);
          break;

        case 'playerJoin':
          this.events.onPlayerJoin && this.events.onPlayerJoin(response.data);
          break;
      }
    };
    this.socket.onclose = (e) => {
      this.events?.onDisconnect && this.events?.onDisconnect();
    };
    this.socket.onopen = () => {
      this.events?.onConnect && this.events?.onConnect();
    };
  }
  disconnect() {
    this.socket && this.socket.close();
  }

  jump(request: PlayerJumpRequest): void {
    this.socket &&
      this.socket.send(
        JSON.stringify({
          action: 'viewer-jump',
          jwt: ClientSocketOptions.getJwt(),
          data: request,
        })
      );
  }

  timeout(request: PlayerTimeoutRequest): void {
    this.socket &&
      this.socket.send(
        JSON.stringify({
          action: 'viewer-timeout',
          jwt: ClientSocketOptions.getJwt(),
          data: request,
        })
      );
  }

  join(request: PlayerJoinRequest): void {
    this.socket &&
      this.socket.send(
        JSON.stringify({
          action: 'viewer-join',
          jwt: ClientSocketOptions.getJwt(),
          data: request,
        })
      );
  }

  ping(request: PlayerPingRequest): void {
    this.socket &&
      this.socket.send(
        JSON.stringify({
          action: 'viewer-ping',
          jwt: ClientSocketOptions.getJwt(),
          data: request,
        })
      );
  }
}

export interface GameSocketEvents {
  onDead: (req: PlayerDeadResponse) => void;

  onWinner: (req: PlayerWinnerResponse) => void;

  onJoin: (req: PlayerOnJoinResponse) => void;

  onGameStarted: (req: PlayerOnGameStartedResponse) => void;

  onJump: (req: PlayerJumpResponse) => void;

  onPlayerJoin: (req: PlayerJoinSocketResponse) => void;

  onDisconnect: () => void;
  onConnect: () => void;
}

export class ViewerClient {
  static async getViewerDetails<TPromise = GetViewerDetailsResponse>(
    model: GetViewerDetailsRequest,
    handle: {
      200?: (result: GetViewerDetailsResponse) => void;
      500?: (result: string) => void;
      400: (result: {error: string}) => void;
      401?: (error: string) => void;
    }
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/viewer/viewer-details?';

    return makeGetRequest(url, model, 'GET', handle);
  }

  static async acquireCredit<TPromise = AcquireCreditResponse>(
    model: AcquireCreditRequest,
    handle: {
      200?: (result: AcquireCreditResponse) => void;
      500?: (result: string) => void;
      400: (result: {error: string}) => void;
      401?: (error: string) => void;
    }
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/viewer/acquire-credit?';

    return makeRequest(url, model, 'POST', handle);
  }

  static async getCreditAvailability<TPromise = CreditAvailabilityResponse>(
    model: VoidRequest,
    handle: {
      200?: (result: CreditAvailabilityResponse) => void;
      500?: (result: string) => void;
      400: (result: {error: string}) => void;
      401?: (error: string) => void;
    }
  ): Promise<TPromise | undefined> {
    let url = ClientOptions.baseUrl + '/viewer/credit-availability?';

    return makeGetRequest(url, model, 'GET', handle);
  }
}

export interface EventRequest {
  eventName: string;
  metaData: string;
  time: string;
}

export interface VoidResponse {}

export interface VoidRequest {}

export interface MetaResponse {
  broadcasts: BounceBlockPartyBroadcasts;
}

export type BounceBlockPartyBroadcasts = {gameId: string} & (
  | {type: 'game-prepped'; preGameStartTime: number}
  | {
      type: 'pre-game';
      gameStartTime: number;
      numberOfPlayers: number;
    }
  | {
      type: 'post-game';
      winner: string;
    }
);

export interface BroadcasterGameStateResponse {
  game?: HttpViewerGameModel;
}

export type HttpViewerGameModel = {
  gameId: string;
  status: GameStatus;
  layout: DbGameLayout;
  preGameStartTime: number;
  gameStartTime?: number;
  winner?: string;
};

export type GameStatus = 'prepping' | 'preGame' | 'live' | 'postGame' | 'inactive';

export type DbGameLayout = {
  platforms: {height: number; width: number; x: number; y: number}[];
};

export interface BroadcasterAuthRequest {
  key: string;
}

export interface BroadcasterAuthResponse {
  jwt: string;
}

export interface NewGamePrepResponse {
  gameId: string;
  preGameStartTime: number;
}

export interface NewGamePregameResponse {
  gameId: string;
  gameStartTime: number;
  numberOfPlayers: number;
}

export interface NewGameStartResponse {
  gameId: string;
}

export interface PlayerDeadResponse {
  playerId: number;
  reason: 'timeout';
}

export interface BroadcasterPlayerWinnerResponse {
  playerId: number;
  playerName: string;
}

export interface PlayerBroadcastJoinResponse {
  player: {x: number; y: number; playerId: number /*skin: PlayerSkin*/};
}

export interface FollowPlayerResponse {
  playerId: number;
}

export interface PlayerJumpResponse {
  angle: number;
  dead: boolean;
  playerId: number;
  time: number;
  velocity: number;
  finalX: number;
  finalY: number;
}

export interface KickOffResponse {
  result: string;
}

export interface GetCurrentGameResponse {
  game?: HttpViewerGameModel;
  gamePlayerId?: string;
}

export interface QueueForGameRequest {}

export interface QueueForGameResponse {
  game: HttpViewerGameModel;
  gamePlayerId: string;
}

export interface PlayerJumpRequest {
  angle: number;
  time: number;
  velocity: number;
}

export interface PlayerTimeoutRequest {}

export interface PlayerJoinRequest {
  botId?: string;
}

export interface PlayerPingRequest {}

export interface PlayerWinnerResponse {}

export interface PlayerOnJoinResponse {
  player: {playerId: number; x: number; y: number};
  players: {playerId: number; x: number; y: number}[];
}

export interface PlayerOnGameStartedResponse {
  time: number;
}

export interface PlayerJoinSocketResponse {
  playerId: number;
  x: number;
  y: number;
}

export interface GetViewerDetailsRequest {}

export interface GetViewerDetailsResponse {
  viewer: HttpViewerModel;
}

export type HttpViewerModel = {
  twitchViewerId?: string;
  twitchOpaqueViewerId?: string;
  twitchViewerName: string;
  viewerId: string;
  credits: number;
};

export interface AcquireCreditRequest {
  acquireType: AcquireType;
}

export type AcquireType =
  | {
      type: 'bits';
      transactionReceipt: string;
    }
  | {
      type: 'subscription';
    }
  | {
      type: 'free-game';
    };

export interface AcquireCreditResponse {
  credits: number;
}

export interface CreditAvailabilityResponse {
  freeGame: boolean;
  subscription: boolean;
}

async function handleResponse(responseText: string, status: number, handle: any) {
  try {
    if (handle[status]) {
      const val = responseText === '' ? null : JSON.parse(responseText);
      await handle[status](val);
      return undefined;
    } else {
      switch (status) {
        case 200: {
          return JSON.parse(responseText);
        }
        case 401: {
          ClientOptions.handleUnauthorized(responseText);
          break;
        }
        case 500: {
          const body = JSON.parse(responseText);
          ClientOptions.handleError(body.error || responseText);
          break;
        }
      }
    }
  } catch (ex) {
    if (!handle[500]) {
      ClientOptions.handleError(ex.toString());
    } else {
      await handle[500](ex.toString());
    }
  }
}
async function makeRequest(url: string, model: any, method: string, handle: any) {
  try {
    const options = {
      method,
    } as RequestInit;

    options.body = JSON.stringify(model);

    const response = await fetch(url, ClientTransformOptions(options));
    const status = response.status;
    const responseText = await response.text();
    return handleResponse(responseText, status, handle);
  } catch (ex) {
    return handleResponse(ex.toString(), 500, handle);
  }
}

async function makeGetRequest(url: string, model: any, method: string, handle: any) {
  try {
    const options = {
      method,
    } as RequestInit;
    url += Object.keys(model)
      .filter((key) => !!(model as any)[key])
      .map((key) => `${key}=${encodeURIComponent((model as any)[key])}`)
      .join('&');

    const response = await fetch(url, ClientTransformOptions(options));
    const status = response.status;
    const responseText = await response.text();
    return handleResponse(responseText, status, handle);
  } catch (ex) {
    return handleResponse(ex.toString(), 500, handle);
  }
}
